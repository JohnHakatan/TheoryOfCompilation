%{
#include "output.hpp"
using namespace std;
extern int yylineno;
void yyerror(const char*);
%}

%token INT
%token BYTE 
%token BOOL
%token B
%token TRUE
%token FALSE
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token ID
%token NUM
%token STRING
%right ASSIGN
%left OR
%left AND
%left EQUALITY
%left RELATIONAL
%left ADDSUB
%left MULDIV
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%nonassoc ELSE

%%

Program: Statements                                                             {output::printProductionRule(1);}
;

Statements: /*epsilon*/                                                          {output::printProductionRule(2);}
          | Statement Statements                                                  {output::printProductionRule(3);}
;

Statement: LBRACE Statements RBRACE                                             {output::printProductionRule(4);}
         | Type ID SC                                                           {output::printProductionRule(5);}
         | Type ID ASSIGN Exp SC                                                {output::printProductionRule(6);}
         | ID ASSIGN Exp SC                                                     {output::printProductionRule(7);}
         | Call SC                                                              {output::printProductionRule(8);}
         | RETURN SC                                                            {output::printProductionRule(9);}
         | RETURN Exp SC                                                        {output::printProductionRule(10);}
         | IF LPAREN Exp RPAREN Statement                                       {output::printProductionRule(11);}
         | IF LPAREN Exp RPAREN Statement ELSE Statement                        {output::printProductionRule(12);}
         | WHILE LPAREN Exp RPAREN Statement                                    {output::printProductionRule(13);}
         | BREAK SC                                                             {output::printProductionRule(14);}
         | CONTINUE SC                                                          {output::printProductionRule(15);}
;

Call: ID LPAREN ExpList RPAREN                                                  {output::printProductionRule(16);}
    | ID LPAREN RPAREN                                                          {output::printProductionRule(17);}
;

ExpList: Exp COMMA ExpList                                                      {output::printProductionRule(18);}
       | Exp                                                                    {output::printProductionRule(19);}
;

Type: INT                                                                       {output::printProductionRule(20);}
    | BYTE                                                                      {output::printProductionRule(21);}
    | BOOL                                                                      {output::printProductionRule(22);}
;

Exp: LPAREN Exp RPAREN                                                          {output::printProductionRule(23);}
   | Exp MULDIV Exp                                                             {output::printProductionRule(24);}
   | Exp ADDSUB Exp                                                             {output::printProductionRule(25);}
   | ID                                                                         {output::printProductionRule(26);}
   | Call                                                                       {output::printProductionRule(27);}
   | NUM                                                                        {output::printProductionRule(28);}
   | NUM B                                                                      {output::printProductionRule(29);}
   | STRING                                                                     {output::printProductionRule(30);}
   | TRUE                                                                       {output::printProductionRule(31);}
   | FALSE                                                                      {output::printProductionRule(32);}
   | NOT Exp                                                                    {output::printProductionRule(33);}
   | Exp AND Exp                                                                {output::printProductionRule(34);}
   | Exp OR Exp                                                                 {output::printProductionRule(35);}
   | Exp EQUALITY Exp                                                           {output::printProductionRule(36);}
   | Exp RELATIONAL Exp                                                         {output::printProductionRule(37);}
   | LPAREN Type RPAREN Exp                                                     {output::printProductionRule(38);}
;

%%

void yyerror(const char* error)
{
    output::errorSyn(yylineno);
    exit(0);
}

int main()
{
    return yyparse();
}
